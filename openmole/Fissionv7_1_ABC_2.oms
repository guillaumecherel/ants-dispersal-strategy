import _parent_._file_.Fissionv7_1_model._
import _parent_._file_.analyse_Fissionv7_1_model._


//val env = EGIEnvironment("vo.complex-systems.eu")


//val seedDouble = Val[Double]


/*
val output_nest1 = Val[Double]
val output_nest2 = Val[Double]
val output_nest3 = Val[Double]
val output_nest4 = Val[Double]
val output_nest5 = Val[Double]
val output_nest6 = Val[Double]
val output_nest7 = Val[Double]
val output_nest8 = Val[Double]
val output_nest9 = Val[Double]
val output_nest10 = Val[Double]

val ObservedNest = Val[Array[Double]]

val colony_number = Val[String]
*/


/*
val mySampling = CSVSampling(workDirectory/ "data_om_2.csv") set (
    columns += ("input_size", size_initial_colony),
    columns += ("output_nest1", output_nest1),
    columns += ("output_nest2", output_nest2),
    columns += ("output_nest3", output_nest3),
    columns += ("output_nest4", output_nest4),
    columns += ("output_nest5", output_nest5),
    columns += ("output_nest6", output_nest6),
    columns += ("output_nest7", output_nest7),
    columns += ("output_nest8", output_nest8),
    columns += ("output_nest9", output_nest9),
    columns += ("output_nest10", output_nest10),
    columns += ("colony", colony_number),
    separator := ','
)
*/




/*
val createVectorObservedNest = ScalaTask ("""
    val ObservedNest: Array[Double] = 
        Array(output_nest1,output_nest2,output_nest3,output_nest4,output_nest5,output_nest6,
        output_nest7,output_nest8,output_nest9,output_nest10
  """) set (
    inputs += (output_nest1,output_nest2,output_nest3,output_nest4,output_nest5),
    inputs += (output_nest6,output_nest7,output_nest8,output_nest9,output_nest10),
    outputs += ObservedNest  
)
*/




def setModelParams(n:Int) = ScalaTask (s"""
    val size_initial_colony = ${n.toDouble}
    //val seed = seedDouble.toInt
    println("seed = " ++ seed.toString)
  """) set (
    //inputs +=  (seedDouble),
    inputs +=  (seed),
    outputs +=  (size_initial_colony,seed),  
    seed := 42
)




def setGlobalParameters(N:Int, explo_pahse:Int) = ScalaTask (s"""
    val number_nests = ${N.toDouble} 
    val exploring_phase = ${explo_pahse.toDouble} 
  """) set (
    outputs +=  (number_nests,exploring_phase) 
)



//def abc(obs:Array[Double]) = ABC(
def abc(obs:Array[Double]) = IslandABC(
    evaluation = Strain( setModelParams(obs.sum.toInt) ) -- (Fission_v7Task hook DisplayHook(seed) ) -- Strain(outputPostProcess) ,
    prior = Prior(
        UniformPrior(nest_quality_assessment_error, 0, 50),
        UniformPrior(percentage_foragers, 3, 100) //,
        //UniformPrior(seedDouble, Int.MinValue.toDouble, Int.MaxValue.toDouble)
    ),
    observed = Seq(ABC.Observed(raw_resources_new_colonies_10, obs)),
    sample = 500,
    generated = 30,                     // nb sim per job
    minAcceptedRatio = 0.01,
    stopSampleSizeFactor = 5,
    parallelism = 100,
    seed = seed 
)
  



/*
ABC(
   evaluation = model,
   prior = Seq(
     theta1 in (-10.0, 10.0),
     theta2 in (-10.0, 10.0),
     theta3 in (-10.0, 10.0)),
   observed =  Seq(o1 -> 0.0),
   sample = 1000,
   generated = 5000,
   minAcceptedRatio = 0.01,
   stopSampleSizeFactor = 5,
   seed = seed )
 */  
 
 
 

val env = EGIEnvironment("vo.complex-systems.eu")

val upmc = PBSEnvironment(
    user = "monnin",
    host = "mesu.dsi.upmc.fr",
    flavour = PBSPro,
    queue = "beta",                     // to use beta server at HPCave Jussieu
    //nodes = 1,
    //coreByNode = 1,
    //threads = 1,
    wallTime = 30.minutes
)
    // !! wallTime !! high values means low priority in the queue,
    // but values smaller than the one required for computing one job (the longest one) yields crash...




//val hook_abc = (workDirectory / "posteriorSample_${colony_number}", frequency= 50) 


// exploration: abc pour chaque colonie
/*
val myExploration = DirectSampling(
  evaluation = createVectorObservedNest -- (abc hook (workDirectory / "posteriorSample_${colony_number}", frequency= 50) ) ,   // (abc on env hook(hook_abc) )
  sampling = mySampling
)

myExploration 
*/



val data = (workDirectory / "data_om_2.csv").content.split("\n").tail.map{
            row => {val rowarray = row.split(",") ; rowarray.drop(3).map(x =>x.toDouble)  }} //.toMap



val number_nests_ABC = 40
val exploring_phase_ABC = 8000



def output_file(i:Int) = (workDirectory / s"ResultsABC_N=${number_nests_ABC}_explo_phase=${exploring_phase_ABC}/posteriorSample_${i}") 

val abcs = for (i <- 0 until data.length  ) yield {
  abc(data(i)).hook(output_file(i), frequency= 20)     
}


//EmptyTask() -- setGlobalParameters(40,2500) -- abcs.map(_ on env)

//EmptyTask() -- setGlobalParameters(40,2500) -- ( abcs(0) on env )  
//EmptyTask() -- setGlobalParameters(40,2500) -- ( abcs(0) )  


// vrai
EmptyTask() -- setGlobalParameters(number_nests_ABC,exploring_phase_ABC) -- abcs.map(_ on env)  



//////// dossiers de rÃ©sultats:
//// ResultsABC_test4:
// EmptyTask() -- setGlobalParameters(40,2500) -- ( abcs(0) on env )  


// ordre:
// 1 
// number_nests_ABC = 40
// exploring_phase_ABC = 2500

// 2
// number_nests_ABC = 20
// exploring_phase_ABC = 2500

// 3 
// number_nests_ABC = 60
// exploring_phase_ABC = 2500

// 4
// number_nests_ABC = 40
// exploring_phase_ABC = 1000

// 5
// number_nests_ABC = 20
// exploring_phase_ABC = 1000

// 6
// number_nests_ABC = 60
// exploring_phase_ABC = 1000




// 7
// number_nests_ABC = 40
// exploring_phase_ABC = 4000

// 8
// number_nests_ABC = 20
// exploring_phase_ABC = 4000

// 9
// number_nests_ABC = 60
// exploring_phase_ABC = 4000


// 10
// number_nests_ABC = 40
// exploring_phase_ABC = 6000


// 11
// number_nests_ABC = 40
// exploring_phase_ABC = 8000





